{
    "collab_server" : "",
    "contents" : "# Create movies_small\nlibrary(ggplot2)\nlibrary(ggplot2movies)\nlibrary(tidyr)\nlibrary(MASS)\nlibrary(dplyr)\nlibrary(datasets)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(ggtern)\nlibrary(geomnet)\nlibrary(ggfortify)\nlibrary(ggmap)\nlibrary(ggthemes)\nlibrary(rgdal)\nlibrary(gganimate)\nlibrary(car)\nlibrary(grid)\nlibrary(gtable)\nlibrary(aplpack)\n\nset.seed(123)\nmovies_small <- movies[sample(nrow(movies), 1000), ]\nmovies_small$rating <- factor(round(movies_small$rating))\n\n\n# 1. Chapter 1: ---- \n# Statistical plots\n\n  # Refresher (1) ----\n  # Explore movies_small with str()\n  str(movies_small)\n  \n  # Build a scatter plot with mean and 95% CI\n  ggplot(movies_small, aes(x = rating, y = votes)) +\n    geom_point() +\n    stat_summary(fun.data = \"mean_cl_normal\",\n                 geom = \"crossbar\",\n                 width = 0.2,\n                 col = \"red\") +\n    scale_y_log10()\n  \n  # Refresher (2) ----\n  # Reproduce the plot\n  ggplot(diamonds, aes(x = carat, y = price, col = color)) +\n    geom_point(alpha = 0.5, size = 0.5, shape = 16) +\n    scale_x_log10(expression(log[10](Carat)), limits = c(0.1,10)) +\n    scale_y_log10(expression(log[10](Price)), limits = c(100,100000)) +\n    scale_color_brewer(palette = \"YlOrRd\") +\n    coord_equal(1:1) + \n    theme_classic()\n  \n  \n  \n  # Refresher (3) ----\n  # Add smooth layer and facet the plot\n  ggplot(diamonds, aes(x = carat, y = price, col = color)) +\n    geom_point(alpha = 0.5, size = .5, shape = 16) +\n    scale_x_log10(expression(log[10](Carat)), limits = c(0.1,10)) +\n    scale_y_log10(expression(log[10](Price)), limits = c(100,100000)) +\n    scale_color_brewer(palette = \"YlOrRd\") +\n    coord_equal() +\n    theme_classic() +\n    stat_smooth(method = \"lm\") +\n    facet_grid(. ~ cut)\n  \n  \n  \n  \n  \n  # Box Plots -----\n  # Transformations\n  # movies_small is available\n  \n  # Add a boxplot geom\n  d <- ggplot(movies_small, aes(x = rating, y = votes)) +\n    geom_point() +\n    geom_boxplot() +\n    stat_summary(fun.data = \"mean_cl_normal\",\n                 geom = \"crossbar\",\n                 width = 0.2,\n                 col = \"red\")\n  \n  # Untransformed plot\n  d\n  \n  # Transform the scale\n  d + scale_y_log10()\n  \n  # Transform the coordinates\n  d + coord_trans(y = \"log10\")\n  \n  \n  # !!!!Cut it up! ----\n  # Plot object p\n  p <- ggplot(diamonds, aes(x = carat, y = price))\n  \n  # Use cut_interval\n  p + geom_boxplot(aes(group = cut_interval(carat, n = 10)))\n  \n  # Use cut_number\n  p + geom_boxplot(aes(group = cut_number(carat, n = 10)))\n  \n  # Use cut_width\n  p + geom_boxplot(aes(group = cut_width(carat, width = 0.25)))\n  \n  \n  \n  # geom_density() ----\n  # bimodal Distribution\n  mu1 <- log(1)\n  mu2 <- log(50)\n  sig1 <- log(3)\n  sig2 <- log(3)\n  cpct <- 0.4\n  bimodalDistFunc <- function (n,cpct, mu1, mu2, sig1, sig2) {\n  y0 <- rlnorm(n,mean=mu1, sd = sig1)\n  y1 <- rlnorm(n,mean=mu2, sd = sig2)\n  flag <- rbinom(n,size=1,prob=cpct)\n  y <- y0*(1 - flag) + y1*flag\n  }\n  bimodalData <- bimodalDistFunc(n=200,cpct,mu1,mu2, sig1,sig2)\n\n  test_data <- data.frame(norm = rnorm(200), bimodal = bimodalData, uniform = runif(200))\n  # test_data is available\n  \n  # Calculating density: d\n  d <- density(test_data$norm)\n  \n  # Use which.max() to calculate mode\n  mode <- d$x[which.max(d$y)]\n  \n  # Finish the ggplot call\n  ggplot(test_data, aes(x = norm)) +\n    geom_rug() +\n    geom_density() +\n    geom_vline(xintercept = mode, col = \"red\")\n  \n  \n\n  \n  # Combine density plots and histogram ----\n  # test_data is available\n  \n  # Arguments you'll need later on\n  fun_args <- list(mean = mean(test_data$norm), sd = sd(test_data$norm))\n  \n  # Finish the ggplot\n  ggplot(test_data, aes(x = norm)) +\n    geom_histogram(aes(y = ..density..)) +\n    geom_density(col = \"red\") +\n    stat_function(fun = dnorm, args = fun_args, col = \"blue\")\n  \n  \n  \n  # Adjusting density plots ----\n  # small_data is available\n  \n  # Get the bandwith\n  x <- c(-3.5, 0.0, 0.5, 6.0)\n  small_data <- as.data.frame(x)\n  get_bw <- density(small_data$x)$bw\n  \n  # Basic plotting object\n  p <- ggplot(small_data, aes(x = x)) +\n    geom_rug() +\n    coord_cartesian(ylim = c(0,0.5))\n  \n  # Create three plots\n  p + geom_density()\n  p + geom_density(adjust = 0.25)\n  p + geom_density(bw = 0.25 * get_bw)\n  \n  # Create two plots\n  p + geom_density(kernel = \"r\")\n  p + geom_density(kernel = \"e\")\n  \n  \n  \n  # Box plots with varying width ----\n  # Finish the plot\n  ggplot(diamonds, aes(x = cut, y = price)) +\n    geom_boxplot(varwidth = TRUE, aes(col = color)) +\n    facet_grid(. ~ color)\n  \n  \n  # Mulitple density plots ----\n  test_data2 <- gather(test_data)\n  # test_data and test_data2 are available\n  str(test_data)\n  str(test_data2)\n  \n  # Plot with test_data\n  ggplot(test_data, aes(x = norm)) +\n    geom_rug() +\n    geom_density()\n  \n  # Plot two distributions with test_data2\n  ggplot(test_data2, aes(x = value, fill = dist, col = dist)) +\n    geom_rug(alpha = 0.6) +\n    geom_density(alpha = 0.6)\n  \n  \n  \n  # Multiple density plots (2) ----\n  # Individual densities\n  ggplot(msleep[msleep$vore == \"herbi\", ], aes(x = sleep_total, fill = vore)) +\n    geom_density(col = NA, alpha = 0.35) +\n    scale_x_continuous(limits = c(0, 24)) +\n    coord_cartesian(ylim = c(0, 0.3))\n  \n  # With faceting\n  ggplot(msleep, aes(x = sleep_total, fill = vore)) +\n    geom_density(col = NA, alpha = 0.35) +\n    scale_x_continuous(limits = c(0, 24)) +\n    coord_cartesian(ylim = c(0, 0.3)) +\n    facet_wrap(~ vore, nrow = 2)\n  \n  # Note that by default, the x ranges fill the scale\n  ggplot(msleep, aes(x = sleep_total, fill = vore)) +\n    geom_density(col = NA, alpha = 0.35) +\n    scale_x_continuous(limits = c(0, 24)) +\n    coord_cartesian(ylim = c(0, 0.3))\n  \n  # Trim each density plot individually\n  ggplot(msleep, aes(x = sleep_total, fill = vore)) +\n    geom_density(col = NA, alpha = 0.35, trim = TRUE) +\n    scale_x_continuous(limits=c(0,24)) +\n    coord_cartesian(ylim = c(0, 0.3))\n  \n  \n  \n  \n  \n  # Non-weighted density plots ----\n  # Density plot from before\n  ggplot(msleep, aes(x = sleep_total, fill = vore)) +\n    geom_density(col = NA, alpha = 0.35) +\n    scale_x_continuous(limits = c(0, 24)) +\n    coord_cartesian(ylim = c(0, 0.3))\n  \n  # Finish the dplyr command\n  msleep2 <- msleep %>%\n    group_by(vore) %>%\n    mutate(n = n() / nrow(msleep), test = n())\n  \n  # Density plot, weighted\n  ggplot(msleep2, aes(x = sleep_total, fill = vore)) +\n    geom_density(aes(weight = n), col = NA, alpha = 0.35) +\n    scale_x_continuous(limits = c(0, 24)) +\n    coord_cartesian(ylim = c(0, 0.3))\n  \n  # Violin plot\n  ggplot(msleep, aes(x = vore, y = sleep_total, fill = vore)) +\n    geom_violin()\n  \n  # Violin plot, weighted\n  ggplot(msleep2, aes(x = vore, y = sleep_total, fill = vore)) +\n    geom_violin(aes(weight = n), col = NA)\n  \n  \n  \n  \n  \n  # 2D density plots (1) ----\n  # Base layers\n  p <- ggplot(faithful, aes(x = waiting, y = eruptions)) +\n    scale_y_continuous(limits = c(1, 5.5), expand = c(0, 0)) +\n    scale_x_continuous(limits = c(40, 100), expand = c(0, 0)) +\n    coord_fixed(60 / 4.5)\n  \n  # Use geom_density_2d()\n  p + geom_density_2d()\n  \n  # Use stat_density_2d()\n  p + stat_density_2d(h = c(5, 0.5), aes(col = ..level..))\n  \n  \n  \n  \n  # 2D density plots (2) ----\n  # Add viridis color scale\n  ggplot(faithful, aes(x = waiting, y = eruptions)) +\n    scale_y_continuous(limits = c(1, 5.5), expand = c(0,0)) +\n    scale_x_continuous(limits = c(40, 100), expand = c(0,0)) +\n    coord_fixed(60/4.5) +\n    stat_density_2d(geom = \"tile\", aes(fill = ..density..), h=c(5,.5), contour = FALSE) +\n    scale_fill_viridis()\n  \n  \n# 2. Chapter 2: Plots for specific data types (Part 1)  ---- \n# Plots for specific data types \n  \n  # Pair plots and correlation matrices ----\n  # pairs\n  pairs(iris[1:4])\n  \n  # chart.Correlation\n  library(PerformanceAnalytics)\n  chart.Correlation(iris[1:4])\n  \n  # ggpairs\n  library(GGally)\n  ggpairs(mtcars[1:3])\n  \n  \n  \n  \n  \n  # Create a correlation matrix in ggplot2 ---\n  \n  cor_list <- function(x) {\n    L <- M <- cor(x)\n    \n    M[lower.tri(M, diag = TRUE)] <- NA\n    M <- melt(M)\n    names(M)[3] <- \"points\"\n    \n    L[upper.tri(L, diag = TRUE)] <- NA\n    L <- melt(L)\n    names(L)[3] <- \"labels\"\n    \n    merge(M, L)\n  }\n  \n  # Calculate xx with cor_list\n  library(dplyr)\n  xx <- iris %>%\n    group_by(Species) %>%\n    do(cor_list(.[1:4])) \n  \n  # Finish the plot\n  ggplot(xx, aes(x = Var1, y = Var2)) +\n    geom_point(aes(col = points, size = abs(points)), shape = 16) +\n    geom_text(aes(col = labels,  size = abs(labels)), label = round(labels, 2)) +\n    scale_size(range = c(0, 6)) +\n    scale_color_gradient(\"r\", limits = c(-1, 1)) +\n    scale_y_discrete(\"\", limits = rev(levels(xx$Var1))) +\n    scale_x_discrete(\"\") +\n    guides(size = FALSE) +\n    geom_abline(slope = -1, intercept = nlevels(xx$Var1) + 1) +\n    coord_fixed() +\n    facet_grid(. ~ Species) +\n    theme(axis.text.y = element_text(angle = 45, hjust = 1),\n          axis.text.x = element_text(angle = 45, hjust = 1),\n          strip.background = element_blank())\n  \n  \n  \n  # Proportional/stacked bar plots ----\n  # Explore africa\n  library(GSIF)\n  data(afsp)\n  africa <- afsp$horizons %>% \n              rename(Sand = SNDPPT, Silt = SLTPPT, Clay = CLYPPT) %>% \n              select(Sand, Silt, Clay)\n  africa <- africa[complete.cases(africa),]\n  str(africa)\n  \n  # Sample the dataset\n  africa_sample <- africa[sample(1:nrow(africa), size = 50), ]\n  \n  # Add an ID column from the row.names\n  africa_sample$ID <- row.names(africa_sample)\n  \n  # Gather africa_sample\n  library(tidyr)\n  africa_sample_tidy <- gather(africa_sample, key, value, -ID)\n  head(africa_sample_tidy)\n  \n  # Finish the ggplot command\n  ggplot(africa_sample_tidy, aes(x = factor(ID), y = value, fill = key)) +\n    geom_bar(stat = \"identity\") +\n    coord_flip() +\n    scale_x_discrete(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0, 0)) +\n    labs(x = \"Location\", y = \"Composition\", fill = \"Component\") +\n    theme_minimal()\n  \n  \n  \n  # Producing ternary plots ----\n  # Build ternary plot\n  ggtern(africa, aes(x = Sand, y = Silt, z = Clay)) +\n    geom_point(shape = 16, alpha = 0.2)\n  \n  \n  # !!! Adjusting ternary plots ----\n  # ggtern and ggplot2 are loaded\n  \n  # Plot 1\n  ggtern(africa, aes(x = Sand, y = Silt, z = Clay)) +\n    geom_density_tern(alpha = 0.5)\n  \n  # Plot 2\n  ggtern(africa, aes(x = Sand, y = Silt, z = Clay)) +\n    stat_density_tern(aes(fill = ..level.., alpha = ..level..), geom = \"polygon\", alpha = 0.5) + \n    guides(fill = guide_legend(show = FALSE))\n  \n  \n  # Build the network (1) ----\n  # Examine structure of madmen\n  str(geomnet::madmen)\n  \n  # Merge edges and vertices\n  mmnet <- merge(madmen$edges, madmen$vertices,\n                 by.x = \"Name1\", by.y = \"label\",\n                 all = TRUE)\n  \n  # Examine structure of mmnet\n  str(mmnet)\n  \n  \n  \n  # Build the network (2) -----\n  # Finish the ggplot command\n  ggplot(data = mmnet, aes(from_id = Name1, to_id = Name2)) +\n    geom_net(aes(col = Gender), size = 6, linewidth = 1, fontsize = 3, labelcolour = \"black\", labelon = TRUE)\n  \n  \n  \n  # Adjusting the network ----\n  # Tweak the network plot\n  ggplot(data = mmnet, aes(from_id = Name1, to_id = Name2)) +\n    geom_net(aes(col = Gender),\n             size = 6,\n             linewidth = 1,\n             labelon = TRUE,\n             fontsize = 3,\n             labelcolour = \"black\",\n             directed = TRUE) +\n    scale_color_manual(values = c(\"#FF69B4\", \"#0099ff\")) +\n    ggmap::theme_nothing(legend = TRUE) +\n    xlim(c(-0.05, 1.05)) +\n    theme(legend.key = element_blank())\n  \n  \n  \n  # Autoplot on linear models ----\n  # Create linear model: res\n  res <- lm(Volume ~ Girth, data = trees)\n  \n  # Plot res\n  plot(res)\n  \n  # Import ggfortify and use autoplot()\n  library(ggfortify)\n  autoplot(res, ncol = 2)\n  \n  \n  # ggfortify - time series ----\n  library(vars)\n  data(Canada)\n  # ggfortify and Canada are available\n  \n  # Inspect structure of Canada\n  str(Canada)\n  \n  # Call plot() on Canada\n  plot(Canada)\n  \n  # Call autoplot() on Canada\n  autoplot(Canada)\n  \n  \n  \n  # !!! Distance matrices and Multi-Dimensional Scaling (MDS) ----\n  # ggfortify and eurodist are available\n  \n  # Autoplot + ggplot2 tweaking\n  autoplot(eurodist) + labs(x = \"\", y = \"\") +\n    coord_fixed() +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))\n  \n  # Autoplot of MDS\n  autoplot(cmdscale(eurodist, eig = TRUE), label = TRUE, label.size = 3, size = 0)\n  \n  \n  \n  \n  # !!! Plotting K-means clustering ----\n  # Perform clustering\n  iris_k <- kmeans(iris[-5], 3)\n  \n  # Autoplot: color according to cluster\n  autoplot(iris_k, data = iris, frame = TRUE)\n  \n  # Autoplot: color according to species\n  autoplot(iris_k, data = iris, frame = TRUE, col = 'Species')\n  \n  \n  \n  \n  \n  \n  \n# 3. Chapter 3: Plots for specific data types (Part 2)  ---- \n   # Working with maps from the maps package: USA ----\n  # maps, ggplot2, and ggmap are pre-loaded\n  \n  # Use map_data() to create usa\n  usa <- map_data(\"usa\")\n  data(\"us.cities\")\n  cities <- us.cities\n  \n  # Inspect structure of usa\n  str(usa)\n  \n  # Build the map\n  ggplot(usa, aes(x = long, y = lat, group = group)) +\n    geom_polygon() +\n    coord_map() +\n    theme_nothing()\n  \n  \n  # Working with maps from the maps package: adding points ----\n  # usa, cities, and all required packages are available\n  \n  # Finish plot 1\n  ggplot(usa, aes(x = long, y = lat, group = group)) +\n    geom_polygon() +\n    geom_point(data = cities, aes(group = country.etc, size = pop), col = \"red\", shape = 16,alpha = 0.6) +\n    coord_map() +\n    theme_map()\n  \n  # Arrange cities\n  cities_arr <- arrange(cities, pop)\n  \n  # Copy-paste plot 1 and adapt\n  ggplot(usa, aes(x = long, y = lat, group = group)) +\n    geom_polygon(fill = \"grey90\") +\n    geom_point(data = cities_arr, aes(group = country.etc, col = pop, size = 2), shape = 16,alpha = 0.6) +\n    coord_map() +\n    theme_map() +\n    scale_color_viridis()\n  \n  \n  \n  # State choropleth ----\n  # pop and all required packages are available\n  \n  # Use map_data() to create state\n  state <- map_data(\"state\")\n  \n  # Map of states\n  ggplot(state, aes(x =long, y = lat, group = group, fill = region)) +\n    geom_polygon(col = \"white\") +\n    coord_map() +\n    theme_nothing()\n  \n  # Merge state and pop: state2\n  # läuft nicht, weil pop-data nicht verfügbar\n  state2 <- merge(state, pop, by = \"region\")\n  \n  # Map of states with populations\n  ggplot(state2, aes(x =long, y = lat, group = group, fill = Pop_est)) +\n    geom_polygon(col = \"white\") +\n    coord_map() +\n    theme_map()\n  \n  \n  # Map from shapefiles ----\n  # http://www.gadm.org/country, download shapeshile ----\n  # All required packages are available\n  \n  # Import shape information: germany\n  germany <- rgdal::readOGR(dsn = \"shapes_DEU\", layer = \"DEU_adm1\")\n  \n  # fortify germany: bundes\n  bundes <- fortify(germany)\n  \n  # Plot map of germany\n  ggplot(bundes, aes(x = long, y = lat, group = group)) +\n    geom_polygon(fill = \"blue\", col = \"white\") +\n    coord_map() +\n    theme_nothing()\n  \n  \n  \n  # Import shape information: georgia\n  georgia <- rgdal::readOGR(dsn = \"shapes_GEO\", layer = \"GEO_adm3\")\n  \n  # fortify germany: bundes\n  mizebi <- fortify(georgia)\n  \n  # Plot map of germany\n  ggplot(mizebi, aes(x = long, y = lat, group = group)) +\n    geom_polygon(fill = \"blue\", col = \"white\") +\n    coord_map() +\n    theme_nothing()\n  \n  \n  \n  # Choropleth from shapefiles ----\n  # germany, bundes and unemp are available\n  # läuft nicht, weil unemp fehlt\n  \n  # re-add state names to bundes\n  bundes$state <- factor(as.numeric(bundes$id))\n  levels(bundes$state) <- germany$NAME_1\n  \n  # Merge bundes and unemp: bundes_unemp\n  bundes_unemp <- merge(bundes, unemp, by = \"state\")\n  \n  # Update the ggplot call\n  ggplot(bundes_unemp, aes(x = long, y = lat, group = group, fill = unemployment)) +\n    geom_polygon() +\n    coord_map() +\n    theme_map()\n  \n  \n  # Different templates\n  # Create london_map_13 with get_map\n  london_map_13 <- get_map(\"London, England\", zoom = 13)\n  \n  # Create the map of london\n  ggmap(london_map_13)\n  \n  # Experiment with get_map() and use ggmap() to plot it!\n  BadHomburg_map_13 <- get_map(\"Bad Homburg, Georgia\", zoom = 13, maptype = \"toner\", source = \"stamen\")\n  ggmap(BadHomburg_map_13)\n  \n  # Experiment with get_map() and use ggmap() to plot it!\n  Tbilisi_map_13 <- get_map(\"Tbilisi, Georgia\", zoom = 13, maptype = \"hybrid\")\n  ggmap(Tbilisi_map_13)\n  \n  \n  \n  # Mapping points onto a cartographic map -----\n    london_sites <- c(\n    \"Tower of London, London\"             \n    , \"Buckingham Palace, London\"           \n    , \"Tower Bridge, London\"                \n    , \"Westminster Abby, London\"            \n    , \"Queen Elizabeth Olympic Park, London\"    \n  )\n  # london_sites and ggmap are available\n  \n  # Use geocode() to create xx\n  xx <- geocode(london_sites)\n  \n  # Add a location column to xx\n  xx$location <- sub(\", London \", \"\", london_sites)\n  \n  # Get map data\n  london_ton_13 <- get_map(location = \"London, England\", zoom = 13,\n                           source = \"stamen\", maptype = \"toner\")\n  \n  # Add a geom_points layer\n  ggmap(london_ton_13) +\n    geom_point(data = xx, aes(col = location), size = 6)\n  \n  \n  \n  \n  \n  # Mapping points onto a cartographic map -----\n  # london_sites and ggmap are available\n  # Use geocode() to create xx\n  xx <- geocode(london_sites)\n  \n  # Add a location column to xx\n  xx$location <- sub(\", London\", \"\", london_sites)\n  \n  # Get map data\n  london_ton_13 <- get_map(location = \"London, England\", zoom = 13,\n                           source = \"stamen\", maptype = \"toner\")\n  \n  # Add a geom_points layer\n  ggmap(london_ton_13) +\n    geom_point(data = xx, aes(col = location), size = 6)\n  \n  \n  \n  \n  \n  \n  \n  # Using a bounding box ----\n  # london_sites and ggmap are available\n  \n  # Build xx\n  xx <- geocode(london_sites)\n  xx$location <- sub(\", London\", \"\", london_sites)\n  xx$location[5] <- \"Queen Elizabeth\\nOlympic Park\"\n  \n  # Create bounding box: bbox\n  bbox <- make_bbox(lon = xx$lon, lat = xx$lat, f = 0.3)\n  \n  # Update get_map to use bbox\n  london_ton_13 <- get_map(location = bbox, zoom = 13,\n                           source = \"stamen\", maptype = \"toner\")\n  \n  # Map from previous exercise\n  ggmap(london_ton_13) +\n    geom_point(data = xx, aes(col = location), size = 6)\n  \n  # New map with labels\n  ggmap(london_ton_13) +\n    geom_label(data = xx, aes(label = location), size = 4, fontface = \"bold\", fill = \"grey90\", col = \"#E41A1C\")\n  \n  \n  \n  \n  \n  # Combine cartographic and choropleth maps ----\n  # bundes is available, as are all required packages (oben)\n  \n  # Get the map data of \"Germany\"\n  germany_06 <- get_map(\"Germany\", zoom = 6)\n  \n  # Plot map and polygon on top:\n  ggmap(germany_06) +\n    geom_polygon(data = bundes, aes(x = long, y = lat, group = group), fill = NA, col = \"red\") +\n    coord_map()\n  \n  \n  \n  # The population pyramid ----\n  # Läuft nicht: https://github.com/dgrtwo/gganimate/issues/22, vielleicht ältere Version von ImageMagick installieren\n  # Inspect structure of japan\n  str(japan)\n  \n  # Finish the code inside saveGIF\n  saveGIF({\n    \n    # Loop through all time points\n    for (i in unique(japan$time)) {\n      \n      # Subset japan: data\n      data <- japan[japan$time == i,]\n      \n      # Finish the ggplot command\n      p <- ggplot(data, aes(x = AGE, y = POP, fill = SEX, width = 1)) +\n        coord_flip() +\n        geom_bar(data = data[data$SEX == \"Female\",], stat = \"identity\") +\n        geom_bar(data = data[data$SEX == \"Male\",], stat = \"identity\") +\n        ggtitle(i)\n      \n      print(p)\n      \n    }\n    \n  }, movie.name = \"pyramid.gif\", interval = 0.1)\n  \n  \n  \n  \n  # Animations with gganimate ----\n  # Läuft nicht: https://github.com/dgrtwo/gganimate/issues/22, vielleicht ältere Version von ImageMagick installieren\n  # Vocab, gganimate and ggplot2 are available\n\n  # Update the static plot\n  p <- ggplot(Vocab, aes(x = education, y = vocabulary, frame = year, cumulative = TRUE, color = year, group = year)) +\n    stat_smooth(method = \"lm\", se = FALSE, size = 3)\n  p\n  \n  # Call gg_animate on p\n  gganimate(p, interval = 1.0, filename = \"vocab.gif\")\n  \n  \n\n  \n  \n  \n  \n  \n# 4. Chapter 4: ggplot2 Internals  ---- \n  # Viewport basics (1) ----\n  # Draw rectangle in null viewport\n  grid.rect(gp = gpar(fill = \"grey90\"))\n  \n  # Write text in null viewport\n  grid.text(\"null viewport\")\n  \n  # Draw a line\n  grid.lines(x = c(0,0.75), y = c(0.25, 1), gp = gpar(lty = 2, col = \"red\"))\n  \n  \n  # Viewport basics (2) ----\n  # Create new viewport: vp\n  vp <- viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.5, just = \"center\")\n  \n  # Push vp\n  pushViewport(vp)\n  \n  # Populate new viewport with rectangle\n  grid.rect(gp = gpar(fill = \"blue\"))\n  \n  \n  # !!!Build a plot from scratch (1) ----\n  # Create plot viewport: pvp\n  dev.off()\n  mar <- c(5, 4, 2, 2)\n  pvp <- plotViewport(mar)\n  \n  # Push pvp\n  pushViewport(pvp)\n  \n  # Add rectangle\n  grid.rect(gp = gpar(fill = \"grey80\"))\n  \n  # Create data viewport: dvp\n  dvp <- dataViewport(xData = mtcars$wt, yData = mtcars$mpg)\n  \n  # Push dvp\n  pushViewport(dvp)\n  \n  # Add two axes\n  grid.xaxis()\n  grid.yaxis()\n  \n  \n  \n  # Build a plot from scratch (2) ----\n  # Add text to x axis\n  grid.text(\"Weight\", y = unit(-3, \"lines\"), name = \"xaxis\")\n  \n  # Add text to y axis\n  grid.text(\"MPG\", x = unit(-3, \"lines\"), rot = 90, name = \"yaxis\")\n  \n  # Add points\n  grid.points(x = mtcars$wt, y = mtcars$mpg, pch = 16, name = \"datapoints\")\n  \n  \n  \n  # Modifying a plot with grid.edit ----\n  # Edit \"xaxis\"\n  grid.edit(\"xaxis\", label = \"Miles/(US) gallon\")\n  \n  # Edit \"yaxis\"\n  grid.edit(\"yaxis\", label = \"Weight (1000 lbs)\")\n  \n  # Edit \"datapoints\"\n  grid.edit(\"datapoints\", gp = gpar(col = \"#C3212766\", cex = 2))\n  \n  \n  \n  # Exploring the gTable ----\n  # A simple plot p\n  p <- ggplot(mtcars, aes(x = wt, y = mpg, col = factor(cyl))) + geom_point()\n  \n  # Create gtab with ggplotGrob()\n  gtab <- ggplotGrob(p)\n  \n  # Print out gtab\n  gtab\n  \n  # Extract the grobs from gtab: gtab\n  g <- gtab$grobs\n  \n  # Draw only the legend\n  grid.draw(g[[15]])\n  \n  \n  \n  # Modifying the gTable ----\n  # Code from before\n  p <- ggplot(mtcars, aes(x = wt, y = mpg, col = factor(cyl))) + geom_point()\n  gtab <- ggplotGrob(p)\n  g <- gtab$grobs\n  grid.draw(g[[15]])\n  \n  # Show layout of g[[8]]\n  gtable_show_layout(g[[15]])\n  \n  # Create text grob\n  my_text <- textGrob(label = \"Motor Trend, 1974\", gp = gpar(fontsize = 7, col = \"gray25\"))\n  \n  # Use gtable_add_grob to modify original gtab\n  new_legend <- gtable_add_grob(gtab$grobs[[15]], my_text, 5, 3)\n  \n  # Update in gtab\n  gtab$grobs[[15]] <- new_legend\n  \n  # Draw gtab\n  grid.draw(gtab)\n  \n  \n  \n  # Exploring ggplot objects ----\n  # Simple plot p\n  p <- ggplot(mtcars, aes(x = wt, y = mpg, col = factor(cyl))) + geom_point()\n  \n  # Examine class() and names()\n  class(p)\n  names(p)\n  \n  # Print the scales sub-list\n  p$scales$scales\n  \n  # Update p\n  p <- p +\n    scale_x_continuous(\"Length\", limits = c(4, 8), expand = c(0, 0)) +\n    scale_y_continuous(\"Width\", limits = c(2, 4.5), expand = c(0, 0))\n  \n  # Print the scales sub-list\n  p$scales$scales\n  \n  \n  \n  # ggplot_build and ggplot_table ----\n  # Box plot of mtcars: p\n  p <- ggplot(mtcars, aes(x = factor(cyl), y = wt)) + geom_boxplot()\n  \n  # Create pbuild\n  pbuild <- ggplot_build(p)\n  \n  # a list of 3 elements\n  names(pbuild)\n  \n  # Print out each element in pbuild\n  pbuild$data\n  pbuild$panel\n  pbuild$plot\n  \n  # Create gtab from pbuild\n  gtab <- ggplot_gtable(pbuild)\n  \n  # Draw gtab;\n  # this should give the exact same output as pbuild$plot from before.\n  grid.draw(gtab)\n  \n  \n  \n  # Extracting details ----\n  # Box plot of mtcars: p\n  p <- ggplot(mtcars, aes(x = factor(cyl), y = wt)) + geom_boxplot()\n  \n  # Build pdata\n  pdata <- ggplot_build(p)$data\n  \n  # Access the first element of the list, a data frame\n  pdata <- ggplot_build(p)$data\n  class(pdata[[1]])\n  \n  # Isolate this data frame\n  my_df <- pdata[[1]]\n  \n  # The x labels\n  my_df$group <- ggplot_build(p)$panel$ranges[[1]]$x.labels\n  \n  # Print out specific variables\n  my_df[c(1:6, 11)]\n  \n  \n  \n  # Arranging plots (1) ----\n  # Add a theme (legend at the bottom)\n  g1 <- ggplot(mtcars, aes(wt, mpg, col = cyl)) +\n    geom_point(alpha = 0.5) +\n    theme(legend.position = \"bottom\")\n  \n  # Add a theme (no legend)\n  g2 <- ggplot(mtcars, aes(disp, fill = cyl)) +\n    geom_histogram(position = \"identity\", alpha = 0.5, binwidth = 20) +\n    theme(legend.position = \"none\")\n  \n  # Load gridExtra\n  library(gridExtra)\n  \n  # Call grid.arrange()\n  grid.arrange(g1,g2,ncol = 2)\n  \n  \n  # Arranging plots (2) ----\n  # Definitions of g1 and g2\n  g1 <- ggplot(mtcars, aes(wt, mpg, col = cyl)) +\n    geom_point() +\n    theme(legend.position = \"bottom\")\n  \n  g2 <- ggplot(mtcars, aes(disp, fill = cyl)) +\n    geom_histogram(binwidth = 20) +\n    theme(legend.position = \"none\")\n  \n  # Extract the legend from g1\n  my_legend <- ggplotGrob(g1)$grobs[[15]]  \n  \n  # Create g1_noleg\n  g1_noleg <- g1 +\n    theme(legend.position = \"none\")\n  \n  # Calculate the height: legend_height\n  legend_height <- sum(my_legend$heights)\n  \n  # Arrange g1_noleg, g2 and my_legend\n  grid.arrange(g1_noleg, g2, my_legend, layout_matrix = matrix(c(1, 3, 2, 3), ncol = 2), heights = unit.c(unit(1, \"npc\") - legend_height, legend_height))\n  \n  \n  \n  \n  \n  \n# 5. Chapter 5: Data Munging and Visualization Case Study   ---- \n  # Case Study 1 - Bag Plot ---- \n  # Base package bag plot ----\n  # läuft nicht, weil aplpack -Packet fehlt\n  test_data <- data.frame(x = mtcars$wt, y = mtcars$mpg)\n  \n  # Call bagplot() on test_data\n  # Create a bag plot of test_data data frame with the bagplot() function. The data frame only has two columns, so you won't need to specify the x and y arguments.\n  bagplot(test_data)\n  \n  # Call compute.bagplot on test_data: bag\n  # Call compute.bagplot() on test_data to obtain a named list of all the statistics used to build the bag plot and assign the results to an object called bag.\n  bag <- compute.bagplot(test_data)\n  \n  # Display information\n  # Code to print the hull loop and hull bag are included; add code to print out the outliers (pxy.outlier)\n  bag$hull.loop\n  bag$hull.bag\n  bag$pxy.outlier\n  \n  # Highlight components\n  # Code to add point layers to highlight two of the three aforementioned components in different colors is available. Can you add a points() function to show the outliers in a \"purple\" color?\n  points(bag$hull.loop, col = \"green\", pch = 16)\n  points(bag$hull.bag, col = \"orange\", pch = 16)\n  points(bag$pxy.outlier, col = \"purple\", pch = 16)\n  \n  \n  \n  \n  # Multilayer ggplot2 bag plot ----\n  # bag and test_data are available\n  \n  # Create data frames from matrices\n  hull.loop <- data.frame(x = bag$hull.loop[,1], y = bag$hull.loop[,2])\n  hull.bag <- data.frame(x = bag$hull.bag[,1], y = bag$hull.bag[,2])\n  pxy.outlier <- data.frame(x = bag$pxy.outlier[,1], y = bag$pxy.outlier[,2])\n  \n  # Finish the ggplot command\n  ggplot(test_data, aes(x,  y)) +\n    geom_polygon(data = hull.loop, fill = \"green\") +\n    geom_polygon(data = hull.bag, fill = \"orange\") +\n    geom_point(data = pxy.outlier, col = \"purple\", pch = 16, cex = 1.5)\n  \n  \n  \n  # Creating ggproto functions ----\n  # ggproto for StatLoop (hull.loop)\n  StatLoop <- ggproto(\"StatLoop\", Stat,\n                      required_aes = c(\"x\", \"y\"),\n                      compute_group = function(data, scales) {\n                        bag <- compute.bagplot(x = data$x, y = data$y)\n                        data.frame(x = bag$hull.loop[,1], y = bag$hull.loop[,2])\n                      })\n  \n  # ggproto for StatBag (hull.bag)\n  StatBag <- ggproto(\"StatBag\", Stat,\n                     required_aes = c(\"x\", \"y\"),\n                     compute_group = function(data, scales) {\n                       bag <- compute.bagplot(x = data$x, y = data$y)\n                       data.frame(x = bag$hull.bag[,1], y = bag$hull.bag[,2])\n                     })\n  \n  # ggproto for StatOut (pxy.outlier)\n  StatOut <- ggproto(\"StatOut\", Stat,\n                     required_aes = c(\"x\", \"y\"),\n                     compute_group = function(data, scales) {\n                       bag <- compute.bagplot(x = data$x, y = data$y)\n                       data.frame(x = bag$pxy.outlier[,1], y = bag$pxy.outlier[,2])\n                     })\n  \n  \n  \n  # Creating stat_bag() ----\n  # StatLoop, StatBag and StatOut are available\n  \n  # Combine ggproto objects in layers to build stat_bag()\n  stat_bag <- function(mapping = NULL, data = NULL, geom = \"polygon\",\n                       position = \"identity\", na.rm = FALSE, show.legend = NA,\n                       inherit.aes = TRUE, loop = FALSE, ...) {\n    list(\n      # StatLoop layer\n      layer(\n        stat = StatLoop, data = data, mapping = mapping, geom = geom, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n        params = list(na.rm = na.rm, alpha = 0.35, col = NA, ...)\n      ),\n      # StatBag layer\n      layer(\n        stat = StatBag, data = data, mapping = mapping, geom = geom, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n        params = list(na.rm = na.rm, alpha = 0.35, col = NA,  ...)\n      ),\n      # StatOut layer\n      layer(\n        stat = StatOut, data = data, mapping = mapping, geom = \"point\", \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n        params = list(na.rm = na.rm, alpha = 0.7, col = NA, shape = 21, ...)\n      )\n    )\n  }\n  \n  \n  \n  # Use stat_bag() ----\n  # hull.loop, hull.bag and pxy.outlier are available\n  # stat_bag, test_data and test_data_2 are available\n  \n  # Previous method\n  ggplot(test_data, aes(x = x,  y = y)) +\n    geom_polygon(data = hull.loop, fill = \"green\") +\n    geom_polygon(data = hull.bag, fill = \"orange\") +\n    geom_point(data = pxy.outlier, col = \"purple\", pch = 16, cex = 1.5)\n  \n  # stat_bag\n  ggplot(test_data, aes(x = x,  y = y)) +\n    stat_bag(data = test_data, aes(x = x, y = y), fill = \"black\")\n  \n  # stat_bag on test_data_2\n  ggplot(test_data2, aes(x = x,  y = y)) +\n    stat_bag(data = test_data2, aes(x = x, y = y, fill = treatment))\n  \n  \n  \n  \n  # Case Study II - Weather (Part 1) ----\n  # Step 1: Read in data and examine ----\n  # Import weather data\n  weather <- read.fwf(\"NYNEWYOR.txt\",\n                      header = FALSE,\n                      col.names = c(\"month\", \"day\", \"year\", \"temp\"),\n                      widths = c(14, 14, 13, 4))\n  \n  # Check structure of weather\n  str(weather)\n  \n  # Create past with two filter() calls\n  past <- weather %>%\n    filter(!(month == 2 & day == 29)) %>%\n    filter(year != max(year))\n  \n  # Check structure of past\n  str(past)\n  \n  \n  \n  # Step 2: Summarize history ----\n  # Create new version of past\n  past <- past %>%\n    group_by(year) %>%\n    mutate(yearday = 1:length(day)) %>%\n    ungroup %>%\n    filter(!(temp == 99)) %>%\n    group_by(yearday) %>%\n    mutate(max = max(temp),\n           min = min(temp),\n           avg = mean(temp),\n           CI_lower = Hmisc::smean.cl.normal(temp)[2],\n           CI_upper = Hmisc::smean.cl.normal(temp)[3]) %>%\n    ungroup()\n  \n  # Structure of past\n  str(past)\n  \n  \n  \n  # Step 3: Plot history ----\n  # Adapt historical plot\n  ggplot(past, aes(x = yearday, y = temp)) +\n    geom_point(col = \"#EED8AE\", alpha = 0.3, shape = 16) +\n    geom_linerange(aes(ymin = CI_lower, ymax = CI_upper), col = \"#8B7E66\")\n  \n  \n  \n  # Step 4: Plot present ----\n  # weather and past are available in your workspace\n  \n  # Create present\n  present <- weather %>%\n    filter(!(month == 2 & day == 29)) %>%\n    filter(year == max(year)) %>%\n    group_by(year) %>%\n    mutate(yearday = 1:length(day)) %>%\n    ungroup() %>%\n    filter(temp != -99)\n  \n  # Add geom_line to ggplot command\n  ggplot(past, aes(x = yearday, y = temp)) + \n    geom_point(col = \"#EED8AE\", alpha = 0.3, shape = 16) +\n    geom_linerange(aes(ymin = CI_lower, ymax = CI_upper), col = \"#8B7E66\") + \n    geom_line(data = present)\n  \n  \n  # Step 5: Find new record highs ----\n  # Create past_highs\n  past_highs <- past %>%\n    group_by(yearday) %>%\n    summarise(past_high = max(temp))\n  \n  # Create record_high\n  record_high <- present %>%\n    left_join(past_highs) %>%\n    filter(temp > past_high)\n  \n  # Add record_high information to plot\n  ggplot(past, aes(x = yearday, y = temp)) + \n    geom_point(col = \"#EED8AE\", alpha = 0.3, shape = 16) +\n    geom_linerange(aes(ymin = CI_lower, ymax = CI_upper), col = \"#8B7E66\") +\n    geom_line(data = present) +\n    geom_point(data = record_high, col = \"#CD2626\")\n  \n  \n  \n  # Step 6: Efficiently calculate record highs and lows ----\n  # Create past_extremes\n  past_extremes <- past %>%\n    group_by(yearday) %>%\n    summarise(past_low = min(temp),\n              past_high = max(temp))\n  \n  # Create record_high_low\n  record_high_low <- present %>%\n    left_join(past_extremes) %>%\n    mutate(record = ifelse(temp < past_low, \n                           \"#0000CD\",\n                           ifelse(temp > past_high, \n                                  \"#CD2626\", \n                                  \"#00000000\")))\n  \n  # Structure of record_high_low\n  str(record_high_low)\n  \n  # Add point layer of record_high_low\n  p <- ggplot(past, aes(x = yearday, y = temp)) + \n    geom_point(col = \"#EED8AE\", alpha = 0.3, shape = 16) +\n    geom_linerange(aes(ymin = CI_lower, ymax = CI_upper), col = \"#8B7E66\") +\n    geom_line(data = present) +\n    geom_point(data = record_high_low, aes(col = record)) +\n    scale_color_identity()\n  p\n  \n  \n  # Step 7: Custom legend ----\n  # Finish the function draw_pop_legend\n  draw_pop_legend <- function(x = 0.6, y = 0.2, width = 0.2, height = 0.2, fontsize = 10) {\n    \n    # Finish viewport() function\n    pushViewport(viewport(x = x, y = y, width = width, height = height, just = \"center\"))\n    \n    legend_labels <- c(\"Past record high\",\n                       \"95% CI range\",\n                       \"Current year\",\n                       \"Past years\",\n                       \"Past record low\")\n    \n    legend_position <- c(0.9, 0.7, 0.5, 0.2, 0.1)\n    \n    # Finish grid.text() function\n    grid.text(label = legend_labels, x = 0.12, y = legend_position, \n              just = \"left\", gp = gpar(fontsize = fontsize, col = \"grey20\"))\n    \n    # Position dots, rectangle and line\n    point_position_y <- c(0.1, 0.2, 0.9)\n    point_position_x <- rep(0.06, length(point_position_y))\n    grid.points(x = point_position_x, y = point_position_y, pch = 16,\n                gp = gpar(col = c(\"#0000CD\", \"#EED8AE\", \"#CD2626\")))\n    grid.rect(x = 0.06, y = 0.5, width = 0.06, height = 0.4,\n              gp = gpar(col = NA, fill = \"#8B7E66\"))\n    grid.lines(x = c(0.03, 0.09), y = c(0.5, 0.5),\n               gp = gpar(col = \"black\", lwd = 3))\n    \n    # Add popViewport() for bookkeeping\n    popViewport()\n  }\n  \n  # Print out plotting object p\n  p\n  \n  # Call draw_pop_legend()\n  draw_pop_legend()\n  \n  \n  \n  \n  \n  \n  # !!!Case Study II - Weather (Part 2) ----\n  # Step 1: clean_weather() ----\n  # Finish the clean_weather function\n  clean_weather <- function(file) {\n    weather <- read.fwf(file,\n                        header = FALSE,\n                        col.names = c(\"month\", \"day\", \"year\", \"temp\"),\n                        widths = c(14, 14, 13, 4))\n    weather %>%\n      filter(!(month == 2 & day == 29)) %>%\n      group_by(year) %>%\n      mutate(yearday = 1:length(day)) %>%\n      ungroup() %>%\n      filter(temp != -99)\n  }\n  \n  # Import NYNEWYOR.txt: my_data\n  my_data <- clean_weather(\"NYNEWYOR.txt\")\n  \n  \n  # Step 2: Historical data ----\n  # Create the stats object\n  StatHistorical <- ggproto(\"StatHistorical\", Stat,\n                            compute_group = function(data, scales, params) {\n                              data <- data %>%\n                                filter(year != max(year)) %>%\n                                group_by(x) %>%\n                                mutate(ymin = Hmisc::smean.cl.normal(y)[3],\n                                       ymax = Hmisc::smean.cl.normal(y)[2]) %>%\n                                ungroup()\n                            },\n                            required_aes = c(\"x\", \"y\", \"year\"))\n  \n  # Create the layer\n  stat_historical <- function(mapping = NULL, data = NULL, geom = \"point\",\n                              position = \"identity\", na.rm = FALSE, show.legend = NA, \n                              inherit.aes = TRUE, ...) {\n    list(\n      layer(\n        stat = \"identity\", data = data, mapping = mapping, geom = geom,\n        position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n        params = list(na.rm = na.rm, col = \"#EED8AE\", alpha = 0.3, shape = 16, ...)\n      ),\n      layer(\n        stat = StatHistorical, data = data, mapping = mapping, geom = \"linerange\",\n        position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n        params = list(na.rm = na.rm, col = \"#8B7E66\", ...)\n      )\n    )\n  }\n  \n  # Build the plot\n  my_data <- clean_weather(\"NYNEWYOR.txt\")\n  ggplot(my_data, aes(x = yearday, y = temp, year = year)) +\n    stat_historical()\n  \n  \n  # Step 3: Present data ----\n  # Create the stats object\n  StatPresent <- ggproto(\"StatPresent\", Stat,\n                         compute_group = function(data, scales, params) {\n                           data <- filter(data, year == max(year))\n                         },\n                         required_aes =  c(\"x\", \"y\", \"year\"))\n  \n  # Create the layer\n  stat_present <- function(mapping = NULL, data = NULL, geom = \"line\",\n                           position = \"identity\", na.rm = FALSE, show.legend = NA, \n                           inherit.aes = TRUE, ...) {\n    layer(\n      stat = StatPresent, data = data, mapping = mapping, geom = geom,\n      position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n      params = list(na.rm = na.rm, ...)\n    )\n  }\n  \n  # Build the plot\n  my_data <- clean_weather(\"NYNEWYOR.txt\")\n  ggplot(my_data, aes(x = yearday, y = temp, year = year)) +\n    stat_historical() + \n    stat_present()\n  \n  \n  # Step 4: Extremes ----\n  # Create the stats object\n  StatExtremes <- ggproto(\"StatExtremes\", Stat,\n                          compute_group = function(data, scales, params) {\n                            \n                            present <- data %>%\n                              filter(year == max(year)) \n                            \n                            past <- data %>%\n                              filter(year != max(year)) \n                            \n                            past_extremes <- past %>%\n                              group_by(x) %>%\n                              summarise(past_low = min(y),\n                                        past_high = max(y))\n                            \n                            # transform data to contain extremes\n                            data <- present %>%\n                              left_join(past_extremes) %>%\n                              mutate(record = ifelse(y < past_low, \n                                                     \"#0000CD\", \n                                                     ifelse(y > past_high, \n                                                            \"#CD2626\", \n                                                            \"#00000000\")))\n                          },\n                          required_aes = c(\"x\", \"y\", \"year\"))\n  \n  # Create the layer\n  stat_extremes <- function(mapping = NULL, data = NULL, geom = \"point\",\n                            position = \"identity\", na.rm = FALSE, show.legend = NA, \n                            inherit.aes = TRUE, ...) {\n    layer(\n      stat = StatExtremes, data = data, mapping = mapping, geom = geom,\n      position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n      params = list(na.rm = na.rm, ...)\n    )\n  }\n  \n  # Build the plot\n  my_data <- clean_weather(\"NYNEWYOR.txt\")\n  ggplot(my_data, aes(x = yearday, y = temp, year = year)) +\n    stat_historical() +\n    stat_present() +\n    stat_extremes(aes(col = ..record..)) +\n    scale_color_identity()\n  \n  \n  # Step 5: Re-use plotting style ----\n  # File paths of all datasets\n  my_files <- c(\"NYNEWYOR.txt\",\"FRPARIS.txt\", \"ILREYKJV.txt\", \"UKLONDON.txt\")\n  \n  # Build my_data with a for loop\n  my_data <- NULL\n  for (file in my_files) {\n    temp <- clean_weather(file)\n    temp$id <- gsub(\".txt\",\"\",file)\n    my_data <- rbind(my_data, temp)\n  }\n  \n  # Build the final plot, from scratch!\n  ggplot(my_data, aes(x = yearday, y = temp, year = year)) +\n    stat_historical() +\n    stat_present() +\n    stat_extremes(aes(col = ..record..)) +\n    scale_color_identity() +\n    facet_wrap(~id, ncol = 2)\n  ",
    "created" : 1494775909305.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1934766300",
    "id" : "EDBBE02F",
    "lastKnownWriteTime" : 1496094031,
    "last_content_update" : 1496094031911,
    "path" : "C:/Users/d91067/Desktop/datacamp/DataVisualization/Data_Visualization_with_ggplot2/Data_Visualization_with_ggplot2_part3.R",
    "project_path" : "Data_Visualization_with_ggplot2_part3.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}