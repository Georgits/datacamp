{
    "collab_server" : "",
    "contents" : "# Chapter 1. Introduction to eXtensible Time Series, using xts and zoo for time series  ----\n# More than a matrix ----\n# Load xts\nlibrary(xts)\n\n# View the structure of ex_matrix\nstr(ex_matrix)\n\n# Extract the 3rd observation of the 2nd column of ex_matrix\nex_matrix[3, 2]\n\n# Extract the 3rd observation of the 2nd column of core \ncore[3, 2]\n\n\n# Your first xts object ----\n# The main xts constructor takes a number of arguments, but the two most important are x for the data and order.by for the index. x must be a vector or matrix. \n# order.by is a vector which must be the same length or number of rows as x, be a proper time or date object (very important!), and be in increasing order.\n\n# Create the object data using 5 random numbers\ndata <- rnorm(5)\n\n# Create dates as a Date class object starting from 2016-01-01\ndates <- seq(as.Date(\"2016-01-01\"), length = 5, by = \"days\")\n\n# Use xts() to create smith\nsmith <- xts(x = data, order.by = dates)\n\n# Create bday (1899-05-08) using a POSIXct date class object\nbday <- as.POSIXct(\"1899-05-08\")\n\n# Create hayek and add a new attribute called born\nhayek <- xts(x = data, order.by = dates, born = bday)\nstr(hayek)\n# xts also allows you to bind arbitrary key-value attributes to your data. This lets you keep metadata about your object inside your object. \n# To add these at creation, you simply pass additional name = value arguments to the xts() function.\n\n\n# Deconstructing xts ----\n# When working with time series, it will sometimes be necessary to separate your time series into its core data and index attributes for additional \n# analysis and manipulation. The core data is the matrix portion of xts. You can separate this from the xts object using coredata(). \n# The index portion of the xts object is available using the index() function. Note that both of these functions are methods from the zoo class, \n# which xts extends.\n# Extract the core data of hayek\nhayek_core <- coredata(hayek)\n\n# View the class of hayek_core\nclass(hayek_core)\n\n# Extract the index of hayek\nhayek_index <- index(hayek)\n\n# View the class of hayek_index\nclass(hayek_index)\n\n\n\n# Time based indices ----\n# Create dates\ndates <- as.Date(\"2016-01-01\") + 0:4\n\n# Create ts_a\nts_a <- xts(x = 1:5, order.by = dates)\n\n# Create ts_b\nts_b <- xts(x = 1:5, order.by = as.POSIXct(dates))\n\n# Extract the rows of ts_a using the index of ts_b\nts_a[index(ts_b)]\n\n# Extract the rows of ts_b using the index of ts_a\nts_b[index(ts_a)]\n\n\n# Converting xts objects ----\n# Convert austres to an xts object called au\nau <- as.xts(austres)\n\n# Then convert your xts object (au) into a matrix am\nam <- as.matrix(au)\n\n# Inspect the head of am\nhead(am)\n\n# Convert the original austres into a matrix am2\nam2 <- as.matrix(austres)\n\n# Inspect the head of am2\nhead(am2)\n\n\n\n# Importing data ----\n# Create dat by reading tmp_file\ndat <- read.csv(tmp_file)\n\n# Convert dat into xts\nxts(dat, order.by = as.Date(rownames(dat), \"%m/%d/%Y\"))\n\n# Read tmp_file using read.zoo\ndat_zoo <- read.zoo(tmp_file, index.column = 0, sep = \",\", format = \"%m/%d/%Y\")\n\n# Convert dat_zoo to xts\ndat_xts <- xts(dat_zoo)\n\n\n\n# Exporting xts objects ----\n# There are two main use cases for exporting xts objects. First, you may require an object to persist across sessions for use in later analysis. \n# In this case, it is almost always best to use saveRDS() and readRDS() to serialize single R objects.\n# Alternatively, you may find yourself needing to share the results of your analysis with others, often expecting the data to be consumed by processes \n# unaware of both R and xts. Most of us would prefer not to think of this horrible fate for our data, but the real world mandates that we at least \n# understand how this works.\n# One of the best ways to write an xts object from R is to use the zoo function write.zoo(). \n# Convert sunspots to xts using as.xts().\nsunspots_xts <- as.xts(sunspots)\n\n# Get the temporary file name\ntmp <- tempfile()\n\n# Write the xts object using zoo to tmp \nwrite.zoo(sunspots_xts, sep = \",\", file = tmp)\n\n# Read the tmp file. FUN = as.yearmon converts strings such as Jan 1749 into a proper time class\nsun <- read.zoo(tmp, sep = \",\", FUN = as.yearmon)\n\n# Convert sun into xts. Save this as sun_xts\nsun_xts <- as.xts(sun)\n\n\n\n# Chapter 2. First Order of Business - Basic Manipulations ----\n# Querying for dates----\n# Select all of 2016 from x\nx_2016 <- x[\"2016\"]\n\n# Select January 1, 2016 to March 22, 2016\njan_march <- x[\"2016-01-01/2016-03-22\"]\n\n# Verify that jan_march contains 82 rows\n82 == length(jan_march)\n\n\n\n# Extracting recurring intraday intervals ----\n# Extract all data from irreg between 8AM and 10AM\nmorn_2010 <- irreg[\"T08:00/T10:00\"]\n\n# Extract the observations in morn_2010 for January 13th, 2010\nmorn_2010[\"2010-01-13\"]\n\n\n\n# Row selection with time objects ----\n# Subset x using the vector dates\nx[dates]\n\n# Subset x using dates as POSIXct\nx[as.POSIXct(dates)]\n\n\n# Update and replace elements ----\n# Replace the values in x contained in the dates vector with NA\nx[dates] <- NA\n\n# Replace all values in x for dates starting June 9, 2016 with 0\nx[index(x) >= \"2016-06-09\"] <- 0\n\n# Verify that the value in x for June 11, 2016 is now indeed 0\nx[\"2016-06-11\"]\n\n\n\n\n#   Find the first or last period of time----\n# Create lastweek using the last 1 week of temps\nlastweek <- last(temps, \"1 week\")\n\n# Print the last 2 observations in lastweek\nlast(lastweek, n = 2)\n\n# Extract all but the first two days of lastweek\nfirst(lastweek, \"-2 days\")\n\n\n\n\n# Combining first and last -----\n# Extract the first three days of the second week of temps\nfirst(last(first(temps, \"2 weeks\"), \"1 week\"), \"3 days\")\n\n\n# Matrix arithmetic - add, subtract, multiply, and divide in time! ----\na <- c(1,1,1)\ndates <- seq(as.Date(\"2015-01-24\"), length = 3, by = \"days\")\na <- xts(x = a, order.by = dates)\n\n\nb <- c(1)\ndates <- seq(as.Date(\"2015-01-24\"), length = 1, by = \"days\")\nb <- xts(x = b, order.by = dates)\n\n# Add a and b\na + b\n\n# Add a with the numeric value of b\na + as.numeric(b)\n\n\n\n# Math with non-overlapping indexes ----\n# Add a to b, and fill all missing rows of b with 0\na + merge(b, index(a), fill = 0)\n\n# Add a to b and fill NAs with the last observation\na + merge(b, index(a), fill = na.locf)\n\n\n\n\n# Chapter 3. Merging and modifying time series ----\n# Combining xts by column with merge ----\n# Perform an inner join of a and b\nmerge(a, b, join = \"inner\")\n\n# Perform a left-join of a and b, fill missing values with 0\nmerge(a, b, join = \"left\", fill = 0)\n\n\n\n\n# Combining xts by row with rbind ----\n# xts provides its own S3 method to the base rbind() generic function. The xts rbind function is much simpler than merge(). \n# The only argument that matters is ..., which takes an arbitrary number of objects to bind. What is different is that\n# rbind requires a time series, since we need to have timestamps for R to know where to insert new data.\n# Row bind temps_june30 to temps, assign this to temps2\ntemps2 <- rbind(temps, temps_june30)\n\n# Row bind temps_july17 and temps_july18 to temps2, call this temps3\ntemps3 <- rbind(temps2, temps_july17, temps_july18)\n\n\n# Fill missing values using last or previous observation ----\n# Fill missing values in temps using the last observation\ntemps_last <- na.locf(temps)\n\n# Fill missing values in temps using the next observation\ntemps_next <- na.locf(temps, fromLast = TRUE)\n\n\n\n\n# NA interpolation using na.approx() ----\n# Based on simple linear interpolation between points, implemented with na.approx() the data points are approximated using the distance \n# between the index values. In other words, the estimated value is linear in time.\n# Interpolate NAs using linear approximation\nna.approx(AirPass)\n\n\n\n# Combine a leading and lagging time series ----\n# Create a leading object called lead_x\nlead_x <- lag(x, k = -1)\n\n# Create a lagging object called lag_x\nlag_x <- lag(x, k = 1)\n\n# Merge your three series together and assign to z\nz <- merge(lead_x, x, lag_x)\n\n\n\n# Calculate a difference of a series using diff() ----\n# Calculate the first difference of AirPass and assign to diff_by_hand\ndiff_by_hand <- AirPass - lag(AirPass, lag = 1)\n\n# Use merge to compare the first parts of diff_by_hand and diff(AirPass)\nmerge(head(diff_by_hand), head(diff(AirPass)))\n\n# Calculate the first order 12 month difference of AirPass\ndiff(AirPass, diff = 1, lag = 12)\n\n\n\n# !!!! What is the key difference in lag between xts and zoo ----\n  # The k argument in xts uses positive values for shifting past observations forward.\n  # In ZOO and BASE R other way around\n\n\n\n\n#  Chapter 4. Apply and aggregate by time  -----\n# Find intervals by time in xts ----\n# Locate the weeks\nendpoints(temps, on = \"weeks\")\n\n# Locate every two weeks\nendpoints(temps, on = \"weeks\", k = 2)\n\n\n# Apply a function by time period(s) ----\n# Calculate the weekly endpoints\nep <- endpoints(temps, on = \"weeks\")\n\n# Now calculate the weekly mean and display the results\nperiod.apply(temps[, \"Temp.Mean\"], INDEX = ep, FUN = mean)\n\n\n\n# Using lapply() and split() to apply functions on intervals ----\n# Split temps by week\ntemps_weekly <- split(temps, f = \"weeks\")\n\n# Create a list of weekly means, temps_avg, and print this list\ntemps_avg <- lapply(X = temps_weekly, FUN = mean)\ntemps_avg\n\n\n\n# !!!! Selection by endpoints vs. split-lapply-rbind ----\n# Note that these functions will always find the dates that are in the closed interval [start of period, \n# end of period] even if there is no observation at the exact start or end. xts represents irregular time series, \n# so it is perfectly valid to have holes in the data where one might expect an observation.\n# Use the proper combination of split, lapply and rbind\n\n# split-lapply-rbind\ntemps_1 <- do.call(rbind, lapply(split(temps, \"weeks\"), function(w) last(w, n = \"1 day\")))\n\n# Create last_day_of_weeks using endpoints()\nlast_day_of_weeks <- endpoints(temps, on = \"weeks\")\n\n# Subset temps using last_day_of_weeks \ntemps_2 <- temps[last_day_of_weeks]\n\n\n\n# !!! Convert univariate series to OHLC data ----\n# Convert usd_eur to weekly and assign to usd_eur_weekly\nusd_eur_weekly <- to.period(usd_eur, period = \"weeks\")\n\n# Convert usd_eur to monthly and assign to usd_eur_monthly\nusd_eur_monthly <- to.period(usd_eur, period = \"months\")\n\n# Convert usd_eur to yearly univariate and assign to usd_eur_yearly\nusd_eur_yearly <- to.period(usd_eur, period = \"years\", OHLC = FALSE)\n\n\n\n\n# Convert a series to a lower frequency ----\n# Depending on the chosen frequency, the index class of your data may be coerced to something more appropriate to the new data. \n# For example, when using the shortcut function to.quarterly(), xts will convert your index to the yearqtr class to make periods more obvious.\n\n# We can override this behavior by using the indexAt argument. Specifically, using firstof would give you the time from the beginning of the period. \n# In addition, you can change the base name of each column by supplying a string to the argument name.\nlibrary(PerformanceAnalytics)\ndata(edhec)\neq_mkt <- edhec\n\n# Convert eq_mkt to quarterly OHLC\nmkt_quarterly <- to.period(eq_mkt, period = \"quarters\")\n\n# Convert eq_mkt to quarterly using shortcut function\nmkt_quarterly2 <- to.quarterly(eq_mkt, name = \"edhec_equity\", indexAt = \"firstof\")\n\n\n\n# !!! Calculate basic rolling value of series by month ----\n\n# x_split <- split(x, f = \"months\")\n# x_list <- lapply(x_split, cummax)\n# x_list_rbind <- do.call(rbind, x_list)\n\n# Split edhec into years\nedhec_years <- split(edhec , f = \"years\")\n\n# Use lapply to calculate the cumsum for each year in edhec_years\nedhec_ytd <- lapply(edhec_years, FUN = cumsum)\n\n# Use do.call to rbind the results\nedhec_xts <- do.call(rbind, edhec_ytd)\n\n\n\n# !!! Calculate the rolling standard deviation of a time series ----\n# Use rollapply to calculate the rolling 3 period sd of eq_mkt\neq_sd <- rollapply(eq_mkt, width = 3, FUN = sd)\n\n\n\n\n# Chapter 5. Extra features of xts ----\n# Time-zone Documentation\nhelp(OlsonNames)\n\n# Class attributes - tclass, tzone, and tformat ----\n# View the first three indexes of temps\nindex(temps)[1:3]\n\n# Get the index class of temps\nindexClass(temps)\n\n# Get the timezone of temps\nindexTZ(temps)\n\n# Change the format of the time display\nindexFormat(temps) <- \"%b-%d-%Y\"\n\n# View the new format\nhead(temps)\n\n\n\n\n# Time Zones (and why you should care!) ----\n# Some internal operation system functions require a time zone to do date math. If a time zone isn't explicitly set, \n# one is chosen for you! Be careful to always set a time zone in your environment to prevent errors when working with dates and times. \n# Construct times_xts with tzone set to America/Chicago\ntimes_xts <- xts(1:10, order.by = times, tzone = \"America/Chicago\")\n\n# Change the time zone of times_xts to Asia/Hong_Kong\ntzone(times_xts) <- \"Asia/Hong_Kong\"\n\n# Extract the current time zone of times_xts\ntzone(times_xts)\n\n\n\n# ! Determining periodicity ----\n# The periodicity() command combined with the to.period() set of commands gives you a simple way to manipulate your time series data. \n# Calculate the periodicity of temps\nperiodicity(temps)\n\n# Calculate the periodicity of edhec\nperiodicity(edhec)\n\n# Convert edhec to yearly\nedhec_yearly <- to.yearly(edhec)\n\n# Calculate the periodicity of edhec_yearly\nperiodicity(edhec_yearly)\n\n\n\n\n\n# Find the number of periods in your data ----\n# Count the months\nnmonths(edhec)\n\n# Count the quarters\nnquarters(edhec)\n\n# Count the years\nnyears(edhec)\n\n\n\n# Secret index tools ---\n# More useful than extracting raw seconds is the ability to extract time components similar to the POSIXlt class, which closely mirrors the underlying POSIX internal compiled structure tm.\n# This functionality is provided by a handful of commands such as .indexday(), .indexmon(), .indexyear(), and more.\n# Explore underlying units of temps in two commands: .index() and .indexwday()\n.index(temps)\n.indexwday(temps)\n\n# Create an index of weekend days using which()\nindex <- which(.indexwday(temps) == 6 | .indexwday(temps) == 0)\n\n# Select the index\ntemps[index]\n\n\n\n\n# Modifying timestamps ----\n# The eps argument, short for epsilon or small change, controls how much identical times should be perturbed, \n# and drop = TRUE lets you just remove duplicate observations entirely.\n# Make z have unique timestamps\nz_unique <- make.index.unique(z, eps = 1e-4)\n\n# Remove duplicate times in z\nz_dup <- make.index.unique(z, drop = TRUE)\n\n# Round observations in z to the next hour\n# On other ocassions you might find your timestamps a bit too precise. In these instances it might be better to round up to some fixed interval, \n# for example an observation may occur at any point in an hour, but you want to record the latest as of the beginning of the next hour. \n# For this situation, the align.time() command will do what you need, setting the n argument to the number of seconds you'd like to round to.\n# Aufrunden auf volle Minute\nz_round <- align.time(z, n = 3600)\n\n\n\n",
    "created" : 1498164698637.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1837687558",
    "id" : "6586EB62",
    "lastKnownWriteTime" : 1498379523,
    "last_content_update" : 1499413733719,
    "path" : "C:/Users/d91067/Desktop/datacamp/Manipulating Time Series Data in R with xts and zoo/xts_zoo.R",
    "project_path" : "xts_zoo.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}