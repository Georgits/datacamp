{
    "collab_server" : "",
    "contents" : "# https://github.com/cwickham/geospatial\n\n# 1. Chapter 1: Basic mapping with ggplot2 and ggmap  -----\n    data(\"sales\")\n    data(\"ward_sales\")\n    data(\"preds\")\n\n# 1.1. Grabbing a background map ----\n    library(ggmap)\n    library(geospatial)\n    corvallis <- c(lon = -123.2620, lat = 44.5646)\n    \n    # Get map at zoom level 5: map_5\n    map_5 <- get_map(corvallis, zoom = 5, scale = 1)\n    \n    # Plot map at zoom level 5\n    ggmap(map_5)\n    \n    # Get map at zoom level 13: corvallis_map\n    corvallis_map <- get_map(corvallis, zoom = 13, scale = 1)\n    \n    # Plot map at zoom level 13\n    ggmap(corvallis_map)\n    \n    # plot Bad Homburg map\n    bad_homburg <- c(lon =  8.61885129999996, lat = 50.2259967)\n    bad_homburg_map <- get_map(bad_homburg, zoom = 16, scale = 1)\n    ggmap(bad_homburg_map)\n    \n    \n    \n# 1.2. Putting it all together -----\n    # Look at head() of sales\n    head(sales) # Diese Daten fehlen\n    \n    # Swap out call to ggplot() with call to ggmap()\n    ggmap(corvallis_map) +\n      geom_point(aes(lon, lat), data = sales)\n    \n# 1.3. Insight through aesthetics -----\n    # Map color to year_built\n    ggmap(corvallis_map) +\n      geom_point(aes(lon, lat, color = year_built), data = sales)\n    \n    # Map size to bedrooms\n    ggmap(corvallis_map) +\n      geom_point(aes(lon, lat, size = bedrooms), data = sales)\n    \n    # Map color to price / finished_squarefeet\n    ggmap(corvallis_map) +\n      geom_point(aes(lon, lat, color = price / finished_squarefeet), data = sales)\n    \n    \n# 1.4. Different maps -----\n    corvallis <- c(lon = -123.2620, lat = 44.5646)\n    \n    # Add a maptype argument to get a satellite map\n    corvallis_map_sat <- get_map(corvallis, zoom = 13, maptype = \"satellite\")\n    \n    # Edit to display satellite map\n    ggmap(corvallis_map_sat) +\n      geom_point(aes(lon, lat, color = year_built), data = sales)\n    \n    # Add source and maptype to get toner map from Stamen Maps\n    corvallis_map_bw <- get_map(corvallis, zoom = 13, maptype = \"toner\", source = \"stamen\")\n    \n    # Edit to display toner map\n    ggmap(corvallis_map_bw) +\n      geom_point(aes(lon, lat, color = year_built), data = sales)\n    \n    \n# 1.5. Leveraging ggplot2's strengths -----\n    # Use base_layer argument to ggmap() to specify data and x, y mappings\n    ggmap(corvallis_map_bw, base_layer =ggplot(sales, aes(lon, lat))) +\n      geom_point(aes(color = year_built))\n    \n    # Use base_layer argument to ggmap() and add facet_wrap()\n    ggmap(corvallis_map_bw, base_layer = ggplot(sales, aes(lon, lat))) +\n      geom_point(aes(color = class)) +\n      facet_wrap(~class)\n    \n# 1.6. A quick alternative -----\n    qmplot(lon, lat, data = sales, \n           geom = \"point\", color = class) +\n      facet_wrap(~ class)\n    \n    \n# 1.7. Drawing polygons -----\n    # Add a point layer with color mapped to ward\n    ggplot(ward_sales, aes(lon, lat)) + \n      geom_point(aes(color = ward))\n    \n    # Add a point layer with color mapped to group\n    ggplot(ward_sales, aes(lon, lat)) + \n      geom_point(aes(color = group))\n    \n    # Add a path layer with group mapped to group\n    ggplot(ward_sales, aes(lon, lat)) + \n      geom_path(aes(group = group))\n    \n    # Add a polygon layer with fill mapped to ward, and group to group\n    ggplot(ward_sales, aes(lon, lat)) + \n      geom_polygon(aes(fill = ward, group = group))\n    \n\n# 1.8. Choropleth map -----\n    # Fix the polygon cropping\n    ggmap(corvallis_map_bw, \n          base_layer = ggplot(ward_sales, aes(lon, lat)), extent = \"normal\", maprange = FALSE) +\n      geom_polygon(aes(group = group, fill = ward))\n    \n    # Repeat, but map fill to num_sales\n    ggmap(corvallis_map_bw, \n          base_layer = ggplot(ward_sales, aes(lon, lat)), extent = \"normal\", maprange = FALSE) +\n      geom_polygon(aes(group = group, fill = num_sales))\n    \n    \n    # Repeat again, but map fill to avg_price\n    # Repeat, but map fill to num_sales\n    ggmap(corvallis_map_bw, \n          base_layer = ggplot(ward_sales, aes(lon, lat)), extent = \"normal\", maprange = FALSE) +\n      geom_polygon(aes(group = group, fill = avg_price), alpha = 0.8)\n\n    \n    \n    \n# 1.8. Raster data as a heatmap -----\n    # Add a geom_point() layer\n    ggplot(preds, aes(lon, lat))  + geom_point()\n    \n    # Add a tile layer with fill mapped to predicted_price\n    ggplot(preds, aes(lon, lat)) +\n      geom_tile(aes(fill = predicted_price))\n    \n    # Use ggmap() instead of ggplot()\n    ggmap(corvallis_map_bw) +\n      geom_tile(data = preds, aes(lon, lat, fill = predicted_price), alpha = 0.8)\n  \n    \n# 2. Chapter 2: Point and polygon data  -----\n    data(\"countries_sp\")\n    data(\"countries_spdf\")\n    data(\"tiny_countries_spdf\")\n\n# 2.1. Let's take a look at a spatial object ----\n    library(sp)\n    \n    # Print countries_sp\n    print(countries_sp)\n    \n    # Call summary() on countries_sp\n    summary(countries_sp)\n    \n    # Call plot() on countries_sp\n    plot(countries_sp)\n    \n# 2.2. What's inside a spatial object? ----\n    # Call str() on countries_sp\n    str(countries_sp)\n    \n    # Call str() on countries_sp with max.level = 2\n    str(countries_sp, max.level = 2)\n    \n    \n# 2.3. A more complicated spatial object ----\n    # Call summary() on countries_spdf and countries_sp\n    summary(countries_sp)\n    summary(countries_spdf)\n    \n    # Call str() with max.level = 2 on countries_spdf\n    str(countries_spdf, max.level = 2)\n    \n    # Plot countries_spdf\n    plot(countries_spdf)\n    \n    \n# 2.4. Walking the hierarchy ----\n    # 169th element of countries_spdf@polygons: one\n    one <- countries_spdf@polygons[[169]]\n    \n    # Print one\n    print(one)\n    \n    # Call summary() on one\n    summary(one)\n    \n    # Call str() on one with max.level = 2\n    str(one, max.level =2)\n    \n    \n# 2.5. Further down the rabbit hole ----\n    one <- countries_spdf@polygons[[169]]\n    \n    # str() with max.level = 2, on the Polygons slot of one\n    str(one@Polygons, max.level = 2)\n    \n    # str() with max.level = 2, on the 6th element of the one@Polygons\n    str(one@Polygons[[6]], max.level = 2)\n    \n    \n    # Call plot on the coords slot of 6th element of one@Polygons\n    plot(one@Polygons[[6]]@coords)\n    \n    \n# 2.6. Subsetting by index ----\n    # Subset the 169th object of countries_spdf: usa\n    usa <- countries_spdf[169,]\n    \n    # Look at summary() of usa\n    summary(usa)\n    \n    # Look at str() of usa\n    str(usa, max.level = 2)\n    \n    # Call plot() on usa\n    plot(usa)\n    \n    \n# 2.7. Accessing data in sp objects ----\n    # Call head() and str() on the data slot of countries_spdf\n    head(countries_spdf@data)\n    str(countries_spdf@data)\n    \n    # Pull out the name column using $\n    countries_spdf$name\n    \n    # Pull out the subregion column using [[\n    countries_spdf[[\"subregion\"]]\n    \n    \n# 2.8. Subsetting based on data attributes ----\n    # Create logical vector: is_nz\n    is_nz <- countries_spdf$name ==\"New Zealand\"\n    \n    # Subset countries_spdf using is_nz: nz\n    nz <- countries_spdf[is_nz,]\n    \n    # Plot nz\n    plot(nz)\n    \n    \n# 2.9. tmap, a package that works with sp objects ----\n    library(sp)\n    library(tmap)\n    \n    # Use qtm() to create a choropleth map of gdp\n    qtm(shp = countries_spdf, fill = \"gdp\") # läuft nicht, nicht klar, warum?\n    \n    \n# 2.10. Building a plot in layers ----\n    library(sp)\n    library(tmap)\n    data(\"Europe\")\n    \n    # Add style argument to the tm_fill() call\n    tm_shape(Europe) +\n      tm_fill(col = \"pop_est\", style = \"quantile\") +\n      # Add a tm_borders() layer \n      tm_borders(col = \"burlywood4\")\n    \n    # New plot, with tm_bubbles() instead of tm_fill()\n    tm_shape(Europe) +\n      tm_bubbles(size = \"pop_est\", style = \"quantile\") +\n      # Add a tm_borders() layer \n      tm_borders(col = \"burlywood4\")\n    \n\n# 2.11. Why is Greenland so big? ----\n    # library(sp)\n    # library(tmap)\n    data(\"World\")\n    \n    # Switch to a Hobo–Dyer projection\n    tm_shape(World, projection = \"hd\") +\n      tm_grid(n.x = 11, n.y = 11) +\n      tm_fill(col = \"pop_est\", style = \"quantile\")  +\n      tm_borders(col = \"burlywood4\") \n    \n    # Switch to a Robinson projection\n    tm_shape(World, projection = \"robin\") +\n      tm_grid(n.x = 11, n.y = 11) +\n      tm_fill(col = \"pop_est\", style = \"quantile\")  +\n      tm_borders(col = \"burlywood4\") \n    \n    # Add tm_style_classic() to your plot\n    tm_shape(World, projection = \"robin\") +\n      tm_grid(n.x = 11, n.y = 11) +\n      tm_fill(col = \"pop_est\", style = \"quantile\")  +\n      tm_borders(col = \"burlywood4\") + \n      tm_style_classic()\n    \n \n# 2.12. Saving a tmap plot ----\n    # library(sp)\n    # library(tmap)\n    \n    # Plot from last exercise\n    tm_shape(World, projection = \"robin\") +\n      tm_grid(n.x = 11, n.y = 11) +\n      tm_fill(col = \"pop_est\", style = \"quantile\")  +\n      tm_borders(col = \"burlywood4\") + \n      tm_style_classic()\n    \n    # Save a static version \"population.png\"\n    save_tmap(filename = \"population.png\")\n    \n    # Save an interactive version \"population.html\"\n    save_tmap(filename = \"population.html\")\n    \n    \n# 3. Chapter 3: Raster data and color  -----\n    data(\"pop\")\n    data(\"pop_by_age\")\n    data(\"prop_by_age\")\n    data(\"migration\")    \n    data(\"land_cover\")\n\n    \n# 3.1. What's a raster object? ----\n    library(raster)\n    data(\"pop\")\n    \n    # Print pop\n    print(pop)\n    \n    # Call str() on pop, with max.level = 2\n    str(pop, max.level = 2)\n    \n    # Call summary on pop\n    summary(pop)\n    \n# 3.2. Some useful methods ----\n    # Call plot() on pop\n    plot(pop)\n    \n    # Call str() on values(pop)\n    str(values(pop))\n    \n    # Call head() on values(pop)\n    head(values(pop))\n\n    \n# 3.3. A more complicated object ----\n    # Print pop_by_age\n    print(pop_by_age)\n    \n    # Subset out the under_1 layer using [[\n    pop_by_age[[\"under_1\"]]\n    \n    # Plot the under_1 layer\n    plot(pop_by_age[[\"under_1\"]])\n    \n    \n# 3.4. A package that uses Raster objects ----\n    library(tmap)\n    \n    # Specify pop as the shp and add a tm_raster() layer\n    tm_shape(pop) +\n      tm_raster()\n    \n    # Plot the under_1 layer in pop_by_age\n    tm_shape(pop_by_age) +\n      tm_raster(col  = \"under_1\")\n\n    library(rasterVis)\n    # Call levelplot() on pop\n    levelplot(pop)\n    \n    \n# 3.5. Adding a custom continuous color palette to ggplot2 plots ----\n    library(RColorBrewer)\n    # 9 steps on the RColorBrewer \"BuPu\" palette: blups\n    blups <- brewer.pal(9, \"BuPu\")\n    \n    # Add scale_fill_gradientn() with the blups palette\n    ggplot(preds) +\n      geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +\n      scale_fill_gradientn(colors = blups)\n\n    library(viridisLite)\n    # viridisLite viridis palette with 9 steps: vir \n    vir <- viridis(n = 9)\n\n    # Add scale_fill_gradientn() with the vir palette\n    ggplot(preds) +\n      geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +\n      scale_fill_gradientn(colors = vir)\n    \n    # mag: a viridisLite magma palette with 9 steps\n    mag <- magma(n = 9)\n    \n    # Add scale_fill_gradientn() with the mag palette\n    ggplot(preds) +\n      geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8)  +\n      scale_fill_gradientn(colors = mag)\n    \n\n# 3.6. Custom palette in tmap ----\n    # Generate palettes from last time\n    library(RColorBrewer)\n    blups <- brewer.pal(9, \"BuPu\")\n    \n    library(viridisLite)\n    vir <- viridis(9)\n    mag <- magma(9)\n    \n    # Use the blups palette\n    tm_shape(prop_by_age) +\n      tm_raster(col = \"age_18_24\", palette = blups) +\n      tm_legend(position = c(\"right\", \"bottom\"))\n    \n    # Use the vir palette\n    tm_shape(prop_by_age) +\n      tm_raster(col = \"age_18_24\", palette = vir) +\n      tm_legend(position = c(\"right\", \"bottom\"))\n    \n    # Use the mag palette but reverse the order\n    tm_shape(prop_by_age) +\n      tm_raster(col = \"age_18_24\", palette = rev(mag)) +\n      tm_legend(position = c(\"right\", \"bottom\"))\n    \n    \n# 3.7. An interval scale example ----\n    library(tmap)\n    library(viridisLite)\n    mag <- viridisLite::magma(7)\n    \n    library(classInt)\n    \n    # Create 5 \"pretty\" breaks with classIntervals()\n    classIntervals(values(prop_by_age[[\"age_18_24\"]]), n = 5, style = \"pretty\")\n    \n    # Create 5 \"quantile\" breaks with classIntervals()\n    classIntervals(values(prop_by_age[[\"age_18_24\"]]), n = 5, style = \"quantile\")\n    \n    # Use 5 \"quantile\" breaks in tm_raster()\n    tm_shape(prop_by_age) +\n      tm_raster(\"age_18_24\", palette = mag, n = 5, style = \"quantile\") +\n      tm_legend(position = c(\"right\", \"bottom\"))\n    \n    # Create histogram of proportions\n    hist(values(prop_by_age[[\"age_18_24\"]]))\n    \n    # Use fixed breaks in tm_raster()\n    tm_shape(prop_by_age) +\n      tm_raster(\"age_18_24\", palette = mag,\n                style = \"fixed\", breaks = c(0.025, 0.05, 0.1, 0.2, 0.25, 0.3, 1))\n    \n    # Save your plot to \"prop_18-24.html\"\n    save_tmap(filename = \"prop_18-24.html\")\n    \n    \n# 3.8. A diverging scale example ----\n    # Print migration\n    print(migration)\n    \n    # Diverging \"RdGy\" palette\n    red_gray <- brewer.pal(7, \"RdGy\")\n    \n    # Use red_gray as the palette \n    tm_shape(migration) +\n      tm_raster(palette = red_gray) +\n      tm_legend(outside = TRUE, outside.position = c(\"bottom\"))\n    \n    # Add fixed breaks \n    tm_shape(migration) +\n      tm_raster(palette = red_gray, style = \"fixed\", breaks = c(-5e6, -5e3, -5e2, -5e1, 5e1, 5e2, 5e3, 5e6)) +\n      tm_legend(outside = TRUE, outside.position = c(\"bottom\"))\n    \n    \n# 3.9. A qualitative example ----\n    library(raster)\n    \n    # Plot land_cover\n    plot(land_cover)\n    tm_shape(land_cover) +\n      tm_raster()\n    \n    # Palette like the ggplot2 default\n    hcl_cols <- hcl(h = seq(15, 375, length = 9), \n                    c = 100, l = 65)[-9]\n    \n    # Use hcl_cols as the palette\n    tm_shape(land_cover) +\n      tm_raster(palette = hcl_cols)\n    \n    \n    # Examine levels of land_cover\n    levels(land_cover)\n    \n    # A set of intuitive colors\n    intuitive_cols <- c(\n      \"darkgreen\",\n      \"darkolivegreen4\",\n      \"goldenrod2\",\n      \"seagreen\",\n      \"wheat\",\n      \"slategrey\",\n      \"white\",\n      \"lightskyblue1\"\n    )\n    \n    # Use intuitive_cols as palette\n    tm_shape(land_cover) +\n      tm_raster(palette = intuitive_cols) +\n      tm_legend(position = c(\"left\", \"bottom\"))\n    \n    \n# 4. Chapter 4: Data import and projections  -----\n    data(\"neighborhoods\")\n    data(\"nyc_income\")\n    data(\"water\")\n    data(\"income_grid\")\n    \n# 4.1. Reading in a shapefile ----\n    library(sp)\n    library(rgdal)\n    \n    # Use dir() to find directory name\n    # download from: https://www1.nyc.gov/site/planning/data-maps/open-data/dwn-nynta.page\n    # Source: Open Data Platform of the Department of City Planning\n    dir()\n    \n    # Call dir() with directory name\n    dir(\"nynta_17a\")\n    \n    # Read in shapefile with readOGR(): neighborhoods\n    neighborhoods <- readOGR(\"nynta_17a\", \"nynta\")\n    \n    # summary() of neighborhoods\n    summary(neighborhoods)\n    \n    # Plot neighboorhoods\n    plot(neighborhoods)\n    \n# 4.2. Reading in a raster file ----\n    library(raster) \n    \n    # Call dir()\n    dir()\n    \n    # Call dir() on the directory\n    dir(\"nyc_grid_data\")\n    \n    # Use raster() with file path: income_grid\n    income_grid <- raster(\"nyc_grid_data/m5602ahhi00.tif\")\n    \n    # Call summary() on income_grid\n    summary(income_grid)\n    \n    # Call plot() on income_grid\n    plot(income_grid)\n    \n    \n# 4.3. Getting data using a package ----\n    library(sp)\n    library(tigris)\n    \n    # Call tracts(): nyc_tracts\n    nyc_tracts <- tracts(state = \"NY\", county = \"New York\", cb = TRUE)\n    \n    # Call summary() on nyc_tracts\n    summary(nyc_tracts)\n    \n    # Plot nyc_tracts\n    plot(nyc_tracts)\n    \n# 4.4. Merging data from different CRS/projections ----\n    library(sp)\n    \n    # proj4string() on nyc_tracts and neighborhoods\n    proj4string(nyc_tracts)\n    proj4string(neighborhoods)\n    \n    # coordinates() on nyc_tracts and neighborhoods\n    head(coordinates(nyc_tracts))\n    head(coordinates(neighborhoods))\n    \n    # plot() neighborhoods and nyc_tracts\n    plot(neighborhoods)\n    plot(nyc_tracts, col = \"red\", add  = TRUE)\n    # Why didn't we see the tracts on our plot of neighborhoods? Simply because the coordinates of the tracts put them way off the boundaries of our plot. \n    \n# 4.5. Merging data from different CRS/projections ----\n    library(sp)\n    library(raster)\n    \n    # Use spTransform on neighborhoods: neighborhoods\n    neighborhoods <- spTransform(neighborhoods, proj4string(nyc_tracts))\n    \n    # head() on coordinates() of neighborhoods\n    head(coordinates(neighborhoods))\n    \n    # Plot neighborhoods, nyc_tracts and water\n    plot(neighborhoods)\n    plot(nyc_tracts, col = \"red\", add  = TRUE)\n    plot(water, col = \"blue\", add  = TRUE)\n    # If you plot the untransformed objects with tmap, it actually does this transformation on the fly, but it's useful to know how to do it manually. \n    \n# 4.6. The wrong way ----\n    # library(sp)\n    # \n    # # Use str() on nyc_income and nyc_tracts@data\n    # str(nyc_income)\n    # str(nyc_tracts@data)\n    # \n    # # Highlight tract 002201 in nyc_tracts\n    # plot(nyc_tracts)\n    # plot(nyc_tracts[nyc_tracts$TRACTCE == \"002201\", ], \n    #      col = \"red\", add = TRUE)\n    # \n    # # Set nyc_tracts@data to nyc_income\n    # nyc_tracts@data <- nyc_income\n    # \n    # # Highlight tract 002201 in nyc_tracts\n    # plot(nyc_tracts)\n    # plot(nyc_tracts[nyc_tracts$tract == \"002201\", ], \n    #      col = \"red\", add = TRUE)\n  \n# 4.7. Checking data will match ----\n    # Check for duplicates in nyc_income\n    any(duplicated(nyc_income$tract))\n    \n    # Check for duplicates in nyc_tracts\n    any(duplicated(nyc_tracts$TRACTCE))\n    \n    # Check nyc_tracts in nyc_income\n    all(nyc_tracts$TRACTCE %in% nyc_income$tract)\n    \n    # Check nyc_income in nyc_tracts\n    all(nyc_income$tract %in% nyc_tracts$TRACTCE)\n    \n    \n# 4.8. Merging data attributes ----\n    library(sp)\n    library(tmap)\n    \n    # Merge nyc_tracts and nyc_income: nyc_tracts_merge\n    nyc_tracts_merge <- merge(nyc_tracts, nyc_income, by.x = \"TRACTCE\", by.y = \"tract\")\n    \n    # Call summary() on nyc_tracts_merge\n    summary(nyc_tracts_merge)\n    \n    # Choropleth with col mapped to estimate\n    tm_shape(nyc_tracts_merge) + \n      tm_fill(col  = \"estimate\")\n    \n    \n# 4.9. A first plot ----\n    library(tmap)\n    \n    tm_shape(nyc_tracts_merge) +\n      tm_fill(col = \"estimate\") +\n      # Add a water layer, tm_fill() with col = \"grey90\"\n      tm_shape(water)  +\n      tm_fill(col = \"grey90\") +\n      # Add a neighborhood layer, tm_borders()\n      tm_shape(neighborhoods) +\n      tm_borders()\n    \n# 4.10. Subsetting the neighborhoods ----\n    library(tmap)\n    \n    # Find unique() nyc_tracts_merge$COUNTYFP\n    unique(nyc_tracts_merge$COUNTYFP)\n    \n    # Add logical expression to pull out New York County\n    manhat_hoods <- neighborhoods[neighborhoods$CountyFIPS == \"061\", ]\n    \n    tm_shape(nyc_tracts_merge) +\n      tm_fill(col = \"estimate\") +\n      tm_shape(water) +\n      tm_fill(col = \"grey90\") +\n      # Edit to use manhat_hoods instead\n      tm_shape(manhat_hoods) +\n      tm_borders() +\n      # Add a tm_text() layer\n      tm_text(text = \"NTAName\")  \n    \n    \n# 4.11. Adding neighborhood labels ----\n    library(tmap)\n    \n    # gsub() to replace \" \" with \"\\n\"\n    manhat_hoods$name <- gsub(\" \", \"\\n\", manhat_hoods$NTAName)\n    \n    # gsub() to replace \"-\" with \"/\\n\"\n    manhat_hoods$name <- gsub(\"-\", \"/\\n\", manhat_hoods$name)\n    \n    # Edit to map text to name, set size to 0.5\n    tm_shape(nyc_tracts_merge) +\n      tm_fill(col = \"estimate\") +\n      tm_shape(water) +\n      tm_fill(col = \"grey90\") +\n      tm_shape(manhat_hoods) +\n      tm_borders() +\n      tm_text(text = \"name\", size = 0.5)\n    \n    \n# 4.12. Tidying up the legend and some final tweaks ----\n    library(tmap)\n    \n    tm_shape(nyc_tracts_merge) +\n      # Add title and change palette\n      tm_fill(col = \"estimate\", \n              title = \"Median Income\",\n              palette = \"Greens\") +\n      # Add tm_borders()\n      tm_borders(col = \"grey60\", lwd = 0.5) +\n      tm_shape(water) +\n      tm_fill(col = \"grey90\") +\n      tm_shape(manhat_hoods) +\n      # Change col and lwd of neighborhood boundaries\n      tm_borders(col = \"grey40\", lwd = 2) +\n      tm_text(text = \"name\", size = 0.5) +\n      # Add tm_credits()\n      tm_credits(\"Source: ACS 2014 5-year Estimates, \\n accessed via acs package\",position = c(\"right\", \"bottom\"))\n    \n    \n    # Save map as \"nyc_income_map.png\"\n    save_tmap(filename = \"nyc_income_map.png\", width = 4, height = 7)\n    save_tmap(filename = \"nyc_income_map.html\", width = 4, height = 7)\n    ",
    "created" : 1491167842607.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1264547735",
    "id" : "9727B03C",
    "lastKnownWriteTime" : 1492370648,
    "last_content_update" : 1505988699917,
    "path" : "C:/Users/d91067/Desktop/datacamp/01_R/SpacialAnalysis/01_Working_with_Geospatial_Data_in_R.R",
    "project_path" : "01_Working_with_Geospatial_Data_in_R.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}